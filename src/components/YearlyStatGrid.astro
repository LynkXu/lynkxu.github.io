---
import StatGrid from './StatGrid.astro';
import StatCard from './StatCard.astro';

interface Props {
  type: 'running' | 'cycling';
  stats: any;
  races?: any[];
}

const { type, stats, races = [] } = Astro.props;

const currentYear = new Date().getFullYear();
// Create list of years: [current, current-1, ...] available in data
// Also ensure '2025' is there if user specifically requested checking 2025.
const availableYears = Object.keys(stats.years || {}).sort().reverse();
const tabs = [currentYear.toString(), ...availableYears.filter(y => y !== currentYear.toString())];

function toFixedTrim(n: number, digits: number) {
  const s = n.toFixed(digits);
  return s.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
}

function avgKmPerCountText(distText: any, count: any) {
  const c = Number(count) || 0;
  const d = Number(distText) || 0;
  if (c <= 0) return 'æš‚æ— è®°å½•';
  const avg = d / c;
  return `~${toFixedTrim(avg, 1)} km/æ¬¡`;
}

function paceText(distKmText: any, timeHoursText: any) {
  const distKm = Number(distKmText) || 0;
  const timeHours = Number(timeHoursText) || 0;
  if (distKm <= 0 || timeHours <= 0) return 'æš‚æ— è®°å½•';
  const totalSeconds = timeHours * 3600;
  const secPerKm = totalSeconds / distKm;
  let mm = Math.floor(secPerKm / 60);
  let ss = Math.round(secPerKm - mm * 60);
  if (ss === 60) {
    mm += 1;
    ss = 0;
  }
  const ssText = String(ss).padStart(2, '0');
  return `~${mm}'${ssText}''/km`;
}

// Construct data attribute for client-side
const dataMap = {
  total: {
    dist: stats.cards.totalDistance.value,
    time: stats.cards.totalTime.value,
    count: stats.cards.totalCount?.value,
    distLabel: stats.cards.totalDistance.label,
    distSub: stats.cards.totalDistance.subtext,
    timeSub: stats.cards.totalTime.subtext,
    countSub: stats.cards.totalCount?.subtext,
  },
  ...Object.fromEntries(
    Object.entries(stats.years || {}).map(([year, data]: [string, any]) => [
      year,
      {
        dist: data.distance,
        time: data.time,
        count: data.count,
        distLabel: type === 'running' ? `${year} è·‘é‡` : `${year} é‡Œç¨‹`,
        // running: è¿™é‡Œæ˜¾ç¤ºâ€œå¹³å‡é€Ÿåº¦/é…é€Ÿâ€ï¼Œéœ€è¦éšå¹´ä»½é‡ç®—ï¼ˆè€Œä¸æ˜¯ä½¿ç”¨ total çš„å¸¸é‡ subtextï¼‰
        distSub: type === 'running' ? paceText(data.distance, data.time) : 'æœ¬å¹´åº¦ç´¯è®¡',
        timeSub: stats.cards.totalTime.subtext,
        countSub: type === 'cycling' ? avgKmPerCountText(data.distance, data.count) : null,
      }
    ])
  )
};

// å½“å‰å¹´ä»½æŒ‰é’®å§‹ç»ˆå­˜åœ¨ï¼Œä½†æ•°æ®å¯èƒ½ä¸å­˜åœ¨ï¼ˆä¾‹å¦‚éª‘è¡Œæ²¡æœ‰ 2026ï¼‰ã€‚
// å¦‚æœä¸å­˜åœ¨ï¼Œå°±è¡¥ä¸€ä¸ªç©ºæ•°æ®ï¼Œé¿å…ç‚¹å‡»æ—¶å›é€€åˆ° total å¯¼è‡´æ˜¾ç¤ºâ€œé”™ä¹±â€ã€‚
const currentYearKey = currentYear.toString();
if (!((dataMap as any)[currentYearKey])) {
  (dataMap as any)[currentYearKey] = {
    dist: '0',
    time: '0',
    count: 0,
    distLabel: type === 'running' ? `${currentYearKey} è·‘é‡` : `${currentYearKey} é‡Œç¨‹`,
    distSub: type === 'running' ? 'æš‚æ— è®°å½•' : 'æœ¬å¹´åº¦ç´¯è®¡',
    timeSub: stats.cards.totalTime.subtext,
    countSub: type === 'cycling' ? 'æš‚æ— è®°å½•' : null,
  };
}

// Initial year shown on first paint should match the active switcher button.
// Always default to current year (even if it has no data).
const initialKey = currentYear.toString();
const initialData =
  (dataMap as any)[initialKey] ??
  {
    dist: '0',
    time: '0',
    count: 0,
    distLabel: type === 'running' ? `${initialKey} è·‘é‡` : `${initialKey} é‡Œç¨‹`,
    distSub: type === 'running' ? 'æš‚æ— è®°å½•' : 'æœ¬å¹´åº¦ç´¯è®¡',
    timeSub: stats.cards.totalTime.subtext,
    countSub: type === 'cycling' ? 'æš‚æ— è®°å½•' : null,
  };

const idPrefix = `stats-${type}`;

// --- Detail View Logic ---
const monthlyData = Array.isArray(stats.monthly) ? stats.monthly : [];

// Group monthly data by year for easier rendering
// Structure: { '2026': [...], '2025': [...], 'total': [...] }
const monthlyGroups: Record<string, any[]> = {
  total: monthlyData // Total always includes everything
};

// Initialize groups for all tabs
tabs.forEach(year => {
  monthlyGroups[year] = monthlyData.filter((m: any) => m.month.startsWith(year));
});

// Helper to check if a year has any monthly data
const hasMonthlyData = (year: string) => monthlyGroups[year] && monthlyGroups[year].length > 0;

// --- Races Data Grouping ---
const racesGroups: Record<string, any[]> = {
  total: races // Total includes all races
};

// Initialize groups for all tabs
tabs.forEach(year => {
  racesGroups[year] = races.filter((r: any) => r.year === year);
});

// Helper to check if a year has any races
const hasRaces = (year: string) => racesGroups[year] && racesGroups[year].length > 0;
---

<div class="stats-switcher-container">
  <div class="stats-switcher" id={`${idPrefix}-switcher`}>
    <button class={`switcher-btn ${initialKey === currentYear.toString() ? 'active' : ''}`} data-year={currentYear.toString()}>{currentYear}</button>
    {tabs.filter(y => y !== currentYear.toString()).map(y => (
      <button class={`switcher-btn ${initialKey === y ? 'active' : ''}`} data-year={y}>{y}</button>
    ))}
    <button class={`switcher-btn ${initialKey === 'total' ? 'active' : ''}`} data-year="total">å…¨éƒ¨</button>
  </div>
</div>

<StatGrid>
  <StatCard
    label={initialData.distLabel}
    value={initialData.dist}
    unit={stats.cards.totalDistance.unit}
    subtext={initialData.distSub}
    id={`${idPrefix}-dist-card`}
  />
  <StatCard
    label={stats.cards.totalTime.label}
    value={initialData.time}
    unit={stats.cards.totalTime.unit}
    subtext={initialData.timeSub}
    id={`${idPrefix}-time-card`}
  />
  
  {type === 'running' ? (
    <>
      <StatCard
        label={stats.cards.halfMarathon.label}
        value={stats.cards.halfMarathon.value}
        unit={stats.cards.halfMarathon.unit}
        subtext={stats.cards.halfMarathon.subtext}
      />
      <StatCard
        label={stats.cards.fullMarathon.label}
        value={stats.cards.fullMarathon.value}
        unit={stats.cards.fullMarathon.unit}
        subtext={stats.cards.fullMarathon.subtext}
      />
    </>
  ) : (
    <>
      <StatCard
        label={stats.cards.totalCount.label}
        value={initialData.count ?? stats.cards.totalCount.value}
        unit={stats.cards.totalCount.unit}
        subtext={initialData.countSub ?? stats.cards.totalCount.subtext}
        id={`${idPrefix}-count-card`}
      />
      <StatCard
        label={stats.cards.farthest.label}
        value={stats.cards.farthest.value}
        unit={stats.cards.farthest.unit}
        subtext={stats.cards.farthest.subtext}
      />
    </>
  )}
</StatGrid>

<div class="detail-section" id={`${idPrefix}-detail-section`}>
  {/* Header Title based on type */}
  <h3>{type === 'running' ? 'æ•°æ®è¯¦æƒ…' : (type === 'cycling' ? 'æœˆåº¦æ±‡æ€»' : 'è¯¦ç»†æ•°æ®')}</h3>
  
  {type === 'cycling' && <div class="section-desc">æŒ‰æœˆç»Ÿè®¡é‡Œç¨‹ä¸é¢‘æ¬¡ï¼Œå›é¡¾éª‘è¡Œè¶‹åŠ¿ã€‚</div>}

  {/* Render detail containers for each year + total */}
  {[...tabs, 'total'].map(year => (
    <div 
      class={`detail-group ${year === initialKey ? 'active' : ''}`} 
      data-year={year}
    >
      {type === 'running' && (
        <>
          <h4 class="subsection-title">æ¯”èµ›è®°å½•</h4>
          {hasRaces(year) ? (
            <div class="table-wrapper" style="margin-bottom: 2rem;">
              <table class="races-table">
                <thead>
                  <tr>
                    <th align="left">æ—¥æœŸ</th>
                    <th align="left">èµ›äº‹åç§°</th>
                    <th align="left">åœ°ç‚¹</th>
                    <th align="left">ç±»å‹</th>
                    <th align="left">çŠ¶æ€</th>
                    <th align="left">æˆç»©</th>
                    <th align="left">é…é€Ÿ</th>
                    <th align="left">å¤‡æ³¨</th>
                  </tr>
                </thead>
                <tbody>
                  {racesGroups[year].map((race: any) => (
                    <tr class={race.status === 'upcoming' ? 'race-upcoming' : 'race-completed'}>
                      <td>{race.date}</td>
                      <td class="race-name">{race.name}</td>
                      <td>{race.location}</td>
                      <td><span class={`race-type-badge ${race.type === 'å…¨é©¬' ? 'full' : 'half'}`}>{race.type}</span></td>
                      <td>
                        <span class={`status-badge ${race.status}`}>
                          {race.status === 'upcoming' ? 'å³å°†è¿›è¡Œ' : 'å·²å®Œæˆ'}
                        </span>
                      </td>
                      <td>{race.time || '-'}</td>
                      <td>{race.pace ? `${race.pace}/km` : '-'}</td>
                      <td class="race-note">{race.note || '-'}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : (
            <div class="empty-state" style="margin-bottom: 2rem;">
              {year === 'total' 
                ? 'æš‚æ— æ¯”èµ›è®°å½•' 
                : `${year} å¹´æš‚æ— æ¯”èµ›è®°å½•`}
            </div>
          )}

          <h4 class="subsection-title">æœˆåº¦è·‘é‡</h4>
        </>
      )}

      {hasMonthlyData(year) ? (
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th align="left">æœˆä»½</th>
                <th align="left">è·ç¦» (km)</th>
                <th align="left">æ¬¡æ•°</th>
                <th align="left">æ—¶é•¿ (h)</th>
                {type === 'running' && <th align="left">å¹³å‡é…é€Ÿ</th>}
              </tr>
            </thead>
            <tbody>
              {monthlyGroups[year].map((row) => (
                <tr>
                  <td>{row.month}</td>
                  <td>{row.distanceKm}</td>
                  <td>{row.count}</td>
                  <td>{row.movingTimeHours}</td>
                  {type === 'running' && <td>{paceText(row.distanceKm, row.movingTimeHours)}</td>}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div class="empty-state">
          {year === 'total'
            ? 'æš‚æ— æœˆåº¦æ•°æ®'
            : `${year} å¹´æš‚æ— æœˆåº¦æ•°æ®`}
        </div>
      )}

      {type === 'running' && (
        <div style="margin-top: 1rem;"></div>
      )}
    </div>
  ))}
</div>

<script define:vars={{ dataMap, idPrefix }}>
  const container = document.getElementById(`${idPrefix}-switcher`);
  const detailSection = document.getElementById(`${idPrefix}-detail-section`);

  if (container) {
    const btns = container.querySelectorAll('.switcher-btn');
    
    // Elements to update
    const distVal = document.querySelector(`#${idPrefix}-dist-card .stat-value`);
    const distLabel = document.querySelector(`#${idPrefix}-dist-card .stat-label`);
    const distSub = document.querySelector(`#${idPrefix}-dist-card .stat-sub`);
    const timeVal = document.querySelector(`#${idPrefix}-time-card .stat-value`);
    const timeSub = document.querySelector(`#${idPrefix}-time-card .stat-sub`);
    const countVal = document.querySelector(`#${idPrefix}-count-card .stat-value`); // might be null for running
    const countSub = document.querySelector(`#${idPrefix}-count-card .stat-sub`); // might be null for running

    btns.forEach(btn => {
      btn.addEventListener('click', () => {
        // Toggle active class for buttons
        btns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const year = btn.getAttribute('data-year');
        const data = dataMap[year] || dataMap['total'];

        // Animate/Update values
        if (distVal) distVal.textContent = data.dist;
        if (distLabel) distLabel.textContent = data.distLabel ?? '';
        if (distSub) distSub.textContent = data.distSub ?? '';
        if (timeVal) timeVal.textContent = data.time;
        if (timeSub) timeSub.textContent = data.timeSub ?? '';
        if (countVal && data.count !== undefined) countVal.textContent = data.count;
        if (countSub) countSub.textContent = data.countSub ?? '';

        // Toggle active class for detail groups
        if (detailSection) {
          const groups = detailSection.querySelectorAll('.detail-group');
          groups.forEach(g => {
            if (g.getAttribute('data-year') === year) {
              g.classList.add('active');
            } else {
              g.classList.remove('active');
            }
          });
        }
      });
    });
  }
</script>

<style>
  /* Local variables for theming with fallbacks */
  .stats-switcher-container {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    margin-bottom: 1.25rem;
    --chip-bg: rgba(0, 0, 0, 0.04); /* ç¨å¾®åŠ æ·± */
    --chip-hover-bg: rgba(0, 0, 0, 0.08);
    --chip-border: rgba(0, 0, 0, 0.12); /* æ˜¾è‘—åŠ æ·± */
    --chip-active-bg: rgba(0, 0, 0, 0.08);
    --chip-active-border: rgba(0, 0, 0, 0.18);
    --chip-text: var(--gray-color, #888);
    --chip-hover-text: var(--text-color, #333);
    --chip-active-text: var(--heading-color, #000);
    --table-border: rgba(0,0,0,0.12); /* æ˜¾è‘—åŠ æ·± */
  }
  
  /* Dark mode overrides using global theme selectors */
  :global([data-theme="dark"]) .stats-switcher-container,
  :global([data-theme="dark"]) .detail-section {
    --chip-bg: rgba(255, 255, 255, 0.08);
    --chip-hover-bg: rgba(255, 255, 255, 0.12);
    --chip-border: rgba(255, 255, 255, 0.15);
    --chip-active-bg: rgba(255, 255, 255, 0.12);
    --chip-active-border: rgba(255, 255, 255, 0.25);
    --chip-text: var(--gray-color, #999);
    --chip-hover-text: var(--text-color, #ddd);
    --chip-active-text: var(--heading-color, #eee);
    --table-border: rgba(255,255,255,0.15);
  }

  @media (prefers-color-scheme: dark) {
    :global(:root:not([data-theme="light"])) .stats-switcher-container,
    :global(:root:not([data-theme="light"])) .detail-section {
      --chip-bg: rgba(255, 255, 255, 0.08);
      --chip-hover-bg: rgba(255, 255, 255, 0.12);
      --chip-border: rgba(255, 255, 255, 0.15);
      --chip-active-bg: rgba(255, 255, 255, 0.12);
      --chip-active-border: rgba(255, 255, 255, 0.25);
      --chip-text: var(--gray-color, #999);
      --chip-hover-text: var(--text-color, #ddd);
      --chip-active-text: var(--heading-color, #eee);
      --table-border: rgba(255,255,255,0.15);
    }
  }
  
  .stats-switcher {
    display: inline-flex;
    align-items: center;
    gap: 0.45rem;
    background: transparent;
    padding: 0;
    border: none;
  }

  .switcher-btn {
    background: var(--chip-bg);
    border: 1px solid var(--chip-border);
    padding: 0.32rem 0.6rem;
    border-radius: 999px;
    font-size: 0.78rem;
    color: var(--chip-text);
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    font-family: inherit;
    font-weight: 550;
    line-height: 1.2;
  }

  .switcher-btn:hover {
    color: var(--chip-hover-text);
    background: var(--chip-hover-bg);
    transform: translateY(-1px);
  }

  .switcher-btn.active {
    background: var(--chip-active-bg);
    color: var(--chip-active-text);
    border-color: var(--chip-active-border);
    font-weight: 650;
  }
  
  .detail-section {
    margin-top: 3rem;
  }
  
  .detail-section h3 {
    font-size: 1.2rem;
    font-weight: 700;
    margin-bottom: 1.5rem;
    color: var(--heading-color);
    letter-spacing: -0.01em;
  }

  .subsection-title {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--heading-color);
    opacity: 0.9;
  }

  .section-desc {
    margin-bottom: 1.5rem;
    color: var(--gray-color);
    font-size: 0.95em;
    border-left: 3px solid var(--heading-color);
    padding-left: 1rem;
    line-height: 1.6;
  }

  /* Detail Groups Toggle Logic */
  .detail-group {
    display: none;
    animation: fadeIn 0.4s ease-out;
  }
  
  .detail-group.active {
    display: block;
    animation: fadeIn 0.4s ease-out; /* ç¡®ä¿æ¯æ¬¡åˆ‡æ¢éƒ½æœ‰æ·¡å…¥æ•ˆæœ */
  }

  .table-wrapper {
    overflow-x: auto;
    border-radius: 12px;
    border: 1px solid var(--table-border);
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9em;
  }
  
  th, td {
    padding: 1rem;
    border-bottom: 1px solid var(--table-border);
    color: var(--text-color);
    text-align: left;
  }
  
  th {
    font-weight: 600;
    color: var(--gray-color);
    background: var(--code-background-color);
    text-transform: uppercase;
    font-size: 0.8em;
    letter-spacing: 0.05em;
  }
  
  tr:last-child td {
    border-bottom: none;
  }

  .empty-state {
    padding: 3rem;
    text-align: center;
    background: var(--code-background-color);
    border-radius: 12px;
    color: var(--gray-color);
    font-size: 0.95em;
    border: 1px dashed var(--table-border);
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Races Table Styles - Unified with Monthly Table */
  .races-table {
    width: 100%;
    border-collapse: collapse; /* Revert to collapse */
    border-spacing: 0;
    font-size: 0.9em; /* Match monthly table font size */
  }

  .races-table th, .races-table td {
    padding: 1rem;
    border-bottom: 1px solid var(--table-border);
    color: var(--text-color);
    text-align: left;
    background: transparent; /* Reset background */
    border: none; /* Reset border */
    border-bottom: 1px solid var(--table-border); /* Keep bottom border only */
  }

  .races-table th {
    font-weight: 600;
    color: var(--gray-color);
    background: var(--code-background-color);
    text-transform: uppercase;
    font-size: 0.8em;
    letter-spacing: 0.05em;
  }

  .races-table tr:last-child td {
    border-bottom: none;
  }
  
  /* Reset special cell styling */
  .races-table td:first-child,
  .races-table td:last-child {
    border-radius: 0;
    border: none;
    border-bottom: 1px solid var(--table-border);
  }
  
  .races-table tr:last-child td:first-child,
  .races-table tr:last-child td:last-child {
    border-bottom: none;
  }

  .races-table .race-name {
    font-weight: 600;
    color: var(--heading-color);
  }

  .races-table .race-note {
    color: var(--gray-color);
    font-size: 0.9em;
    font-style: italic;
    max-width: 200px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Keep status badges but simplify row backgrounds */
  .race-upcoming, .race-completed {
    background: transparent; 
  }

  .status-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    line-height: 1;
    font-family: inherit; /* Inherit font family */
  }

  .status-badge.upcoming {
    background: rgba(14, 165, 233, 0.1); /* Sky 500 opacity */
    color: #0ea5e9; /* Sky 500 */
  }

  .status-badge.completed {
    background: rgba(16, 185, 129, 0.1); /* Emerald 500 opacity */
    color: #059669; /* Emerald 600 */
  }
  
  :global([data-theme="dark"]) .status-badge.upcoming {
    background: rgba(56, 189, 248, 0.15); /* Sky 400 opacity */
    color: #38bdf8; /* Sky 400 */
  }

  :global([data-theme="dark"]) .status-badge.completed {
    background: rgba(52, 211, 153, 0.15); /* Emerald 400 opacity */
    color: #34d399; /* Emerald 400 */
  }

  .race-type-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    line-height: 1;
    font-family: inherit; /* Inherit font family */
  }
  
  /* Full Marathon: Rose/Pink */
  .race-type-badge.full {
    background: rgba(225, 29, 72, 0.1); /* Rose 600 with opacity */
    color: #e11d48; /* Rose 600 */
  }
  
  /* Half Marathon: Indigo */
  .race-type-badge.half {
    background: rgba(79, 70, 229, 0.1); /* Indigo 600 with opacity */
    color: #4f46e5; /* Indigo 600 */
  }

  :global([data-theme="dark"]) .race-type-badge.full {
    background: rgba(251, 113, 133, 0.15); /* Rose 400 with opacity */
    color: #fb7185; /* Rose 400 */
  }

  :global([data-theme="dark"]) .race-type-badge.half {
    background: rgba(129, 140, 248, 0.15); /* Indigo 400 with opacity */
    color: #818cf8; /* Indigo 400 */
  }

  /* Responsive adjustments - simplified */
  @media (max-width: 768px) {
    .races-table {
      display: block;
    }
    .races-table thead {
      display: none;
    }
    .races-table tbody {
      display: block;
    }
    .races-table tr {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      padding: 1rem;
      border-bottom: 1px solid var(--table-border);
    }
    
    .races-table td {
      display: block;
      padding: 0;
      border: none;
    }

    /* Keep mobile card layout logic but simplify styles */
    .races-table td:first-child { grid-column: 1 / -1; font-size: 0.8em; color: var(--gray-color); margin-bottom: 0.2rem; }
    .races-table td:nth-child(2) { grid-column: 1 / -1; font-weight: 700; font-size: 1.1em; margin-bottom: 0.5rem; }
    .races-table td:nth-child(5) { grid-column: 2; grid-row: 1; justify-self: end; }
    
    /* Hide less important columns on mobile or simplify */
    .races-table td:nth-child(3), /* Location */
    .races-table td:nth-child(4), /* Type */
    .races-table td:nth-child(6), /* Time */
    .races-table td:nth-child(7) { /* Pace */
       grid-column: 1 / 3;
       display: inline-block;
       font-size: 0.9rem;
       color: var(--gray-color);
       margin-right: 0.5rem;
    }
    
    /* Add labels for context on mobile */
    .races-table td:nth-child(3)::before { content: 'ğŸ“ '; }
    .races-table td:nth-child(6)::before { content: 'â±ï¸ '; }
    .races-table td:nth-child(7)::before { content: 'âš¡ '; }

    .races-table td:nth-child(8) { /* Note */
       grid-column: 1 / -1; 
       margin-top: 0.5rem; 
       white-space: normal;
       font-size: 0.85rem;
       color: var(--gray-color);
       padding-top: 0.5rem;
       border-top: 1px dashed var(--chip-border);
    }
  }

</style>
